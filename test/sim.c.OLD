#include <stdio.h>
#include "gtk/gtk.h"
#include "atoms.h"
#include "sim.h"
#include "ui_input.h"
#include "afield.h"
#include "ui_afield.h"
#include "ui_graph.h"
#include "ui_label.h"

/* static GCond *atom_changed; */

static void start_disintegration(Atoms *atoms)
{
    GRand *rand;
    gint32 i, pos;
    gdouble htime;
    gulong ht;

    htime = get_halflife_period();

    rand = g_rand_new();

    update_status_label(atoms->states[0]);
    pos = 0;
    while (atoms->states[0] > 0) {
        for (i = atoms->states[0]; i > 0; i--) {
            if (g_rand_boolean(rand)) {
                atoms->states[0]--;
                atoms->states[1]++;
                update_status_label(atoms->states[0]);
                (atoms->list + pos)->state = 1;
                draw_atom((atoms->list + pos)->x, (atoms->list + pos)->y, atoms->wide, (atoms->list + pos)->state);
                pos++;
/*                g_cond_broadcast(atom_changed); */
            }
        }
/*        printf("atoms: %d\tpercent: %.2f\n", atoms->states[0], (gdouble) atoms->states[0] / (gdouble) atoms->number); */
/*        g_usleep(htime * G_USEC_PER_SEC); */
/*        g_usleep((gulong) (htime + 0.5) * G_USEC_PER_SEC); */
        g_usleep(G_USEC_PER_SEC);
    }

    update_status_label(atoms->states[0]);
    g_rand_free(rand);
}

static void start_afield(Atoms *atoms)
{
    gint32 i;
    gtk_idle_add((GtkFunction) clear_atom_field, NULL);

    gtk_idle_add((GtkFunction) draw_atom_field, atoms);

/*    for (i = 0; i < atoms->number; i++) {
        g_cond_wait(atom_changed, NULL);
        draw_atom((atoms->list + i)->x, (atoms->list + i)->y, atoms->wide, (atoms->list + i)->state);
    } */
}

static void start_graph(Atoms *atoms)
{
    gint32 i;
    i = 0;
    atoms = atoms;

    gtk_idle_add((GSourceFunc) clear_graph, NULL);

/*    do {
        g_usleep(G_USEC_PER_SEC);
    } while (atoms->states[0] > 0); */
}

void start_sim(void)
{
    gint32 number;
    GThread *t_afield, *t_graph, *t_disintegration;
    Atoms *atoms;

/*    start_buttons_set_sensitive(FALSE); */

    number = get_atoms_number();
    atoms = create_atoms(number);
    arrange_atoms(atoms);
    randomize_atom_list(atoms->list, atoms->number);

    t_disintegration = g_thread_create((GThreadFunc) start_disintegration, atoms, TRUE, NULL);
    t_afield = g_thread_create((GThreadFunc) start_afield, atoms, TRUE, NULL);
    t_graph = g_thread_create((GThreadFunc) start_graph, atoms, TRUE, NULL);

/*    start_buttons_set_sensitive(TRUE); */

/*    destroy_atoms(atoms); */
}
